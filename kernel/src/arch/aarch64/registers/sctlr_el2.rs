// Copyright (c) 2025 vivo Mobile Communication Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use tock_registers::{interfaces::*, register_bitfields};

register_bitfields! {u64,
    pub SCTLR_EL2 [
        /// Trap IMPLEMENTATION DEFINED functionality.
        TIDCP OFFSET(63) NUMBITS(1) [
            DontTrap = 0,
            Trap = 1,
        ],

        /// SP Interrupt Mask enable.
        SPINTMASK OFFSET(62) NUMBITS(1) [
            Enabled = 0,
            Disabled = 1,
        ],

        /// Non-maskable Interrupt enable.
        NMI OFFSET(61) NUMBITS(1) [],

        /// Tag Checking Store Only.
        TCSO OFFSET(59) NUMBITS(1) [],

        /// Enhanced Privileged Access Never.
        EPAN OFFSET(57) NUMBITS(1) [],

        /// Enables the Transactional Memory Extension at EL2.
        TME OFFSET(53) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// Default PSTATE.SSBS value on Exception Entry.
        DSSBS OFFSET(44) NUMBITS(1) [],

        /// When SCR_EL3.ATA == 1, controls access to Allocation Tags and Tag Check operations in EL2.
        ATA OFFSET(43) NUMBITS(1) [],

        /// Tag Check Fault in EL2. Controls the effect of Tag Check Faults due to Loads and Stores in EL2.
        TCF OFFSET(40) NUMBITS(2) [],

        /// When synchronous exceptions are not being generated by Tag Check Faults,
        /// this field controls whether on exception entry into EL2,
        /// all Tag Check Faults due to instructions executed before exception entry,
        /// that are reported asynchronously, are synchronized into TFSR_EL2 register.
        ITFSB OFFSET(37) NUMBITS(1) [],

        /// When FEAT_BTI is implemented:
        /// Configures the Branch Type compatibility of the implicit BTI behavior for EL2.
        BT1 OFFSET(36) NUMBITS(1) [],

        /// When FEAT_BTI is implemented:
        /// Configures the Branch Type compatibility of the implicit BTI behavior for EL2.
        BT0 OFFSET(35) NUMBITS(1) [],

        /// When FEAT_FPMR is implemented:
        /// Enables direct and indirect accesses to FPMR from EL2.
        ENFPM OFFSET(34) NUMBITS(1) [],

        /// When FEAT_MOPS is implemented:
        /// Memory Copy and Memory Set instructions Enable.
        MSCEN OFFSET(33) NUMBITS(1) [],

        /// Controls cache maintenance instruction permission for EL2.
        CMOW OFFSET(32) NUMBITS(1) [],

        /// When FEAT_PAuth is implemented:
        /// Controls enabling of pointer authentication of instruction addresses, using the APIAKey_EL2 key.
        ENIA OFFSET(31) NUMBITS(1) [
            Disable = 0,
            Enabled = 1,
        ],

        /// When FEAT_PAuth is implemented:
        /// Controls enabling of pointer authentication of instruction addresses, using the APIBKey_EL2 key.
        ENIB OFFSET(30) NUMBITS(1) [
            Disable = 0,
            Enabled = 1,
        ],

        /// When FEAT_LSMAOC is implemented:
        /// Load Multiple and Store Multiple Atomicity and Ordering Enable.
        LSMAOE OFFSET(29) NUMBITS(1) [
            Disable = 0,
            Enabled = 1,
        ],

        /// When FEAT_LSMAOC is implemented:
        /// No Trap Load Multiple and Store Multiple to Device-nGRE/Device-nGnRE/Device-nGnRnE memory.
        NTLSMD OFFSET(28) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// When FEAT_PAuth is implemented:
        /// Controls enabling of pointer authentication of instruction addresses, using the APDAKey_EL2 key.
        ENDA OFFSET(27) NUMBITS(1) [
            Disable = 0,
            Enabled = 1,
        ],

        /// Traps EL2 execution of cache maintenance instructions to EL2 (self).
        UCI OFFSET(26) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// When FEAT_MixedEnd is implemented:
        /// Endianness of data accesses at EL2, and stage 1 translation table walks in the EL2 translation regime.
        EE OFFSET(25) NUMBITS(1) [
            LittleEndian = 0,
            BigEndian = 1,
        ],

        /// When FEAT_PAN is implemented:
        /// Set Privileged Access Never, on taking an exception to EL2.
        SPAN OFFSET(23) NUMBITS(1) [
            Set = 0,
            Unset = 1
        ],

        /// When FEAT_ExS is implemented:
        /// Exception Entry is Context Synchronizing.
        EIS OFFSET(22) NUMBITS(1) [
            NotContextSynchronizingEvent = 0,
            ContextSynchronizingEvent = 1
        ],

        /// When FEAT_IESB is implemented:
        /// Implicit Error Synchronization event enable.
        IESB OFFSET(21) NUMBITS(1) [
            Disable = 0,
            Enable = 1,
        ],

        /// Write permission implies XN (Execute-never).
        WXN OFFSET(19) NUMBITS(1) [
            Disable = 0,
            Enable = 1,
        ],

        /// Traps EL2 execution of WFE instructions to EL2 (self).
        NTWE OFFSET(18) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// Traps EL2 execution of WFI instructions to EL2 (self).
        NTWI OFFSET(16) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// Traps EL2 accesses to the CTR_EL0 to EL2 (self).
        UCT OFFSET(15) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// Traps EL2 execution of DC ZVA instructions to EL2 (self).
        DZE OFFSET(14) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// When FEAT_PAuth is implemented:
        /// Controls enabling of pointer authentication of instruction addresses, using the APDBKey_EL2 key.
        ENDB OFFSET(13) NUMBITS(1) [
            Disable = 0,
            Enable = 1
        ],

        /// Instruction access Cacheability control, for accesses at EL2.
        I OFFSET(12) NUMBITS(1) [
            NonCacheable = 0,
            Cacheable = 1
        ],

        /// When FEAT_ExS is implemented:
        /// Exception Exit is Context Synchronizing.
        EOS OFFSET(11) NUMBITS(1) [
            NotContextSynchronizingEvent = 0,
            ContextSynchronizingEvent = 1
        ],

        /// When FEAT_SPECRES is implemented:
        /// Enable EL2 access to the following System instructions.
        ENRCTX OFFSET(10) NUMBITS(1) [
            Disable = 0,
            Enable = 1
        ],

        /// User Mask Access. Traps EL2 execution of MSR and MRS instructions
        /// that access the PSTATE.{D, A, I, F} masks to EL2.
        UMA OFFSET(9) NUMBITS(1) [
            Trap = 0,
            DontTrap = 1,
        ],

        /// When FEAT_LSE2 is implemented:
        /// Non-aligned access.
        NAA OFFSET(6) NUMBITS(1) [
            Disable = 0,
            Enable = 1
        ],

        /// CP15BEN - System instruction memory barrier enable for EL2.
        CP15BEN OFFSET(5) NUMBITS(1) [
            Disable = 0,
            Enable = 1
        ],

        /// SP Alignment check enable for EL2.
        SA0 OFFSET(4) NUMBITS(1) [
            Disable = 0,
            Enable = 1
        ],

        /// SP Alignment check enable.
        SA OFFSET(3) NUMBITS(1) [
            Disable = 0,
            Enable = 1
        ],

        /// Stage 1 Cacheability control, for data accesses at EL2.
        C OFFSET(2) NUMBITS(1) [
            NonCacheable = 0,
            Cacheable = 1
        ],

        /// Alignment check enable.
        A OFFSET(1) NUMBITS(1) [
            DisableAlignment  = 0,
            EnableAlignment  = 1
        ],

        /// MMU enable for EL2 stage 1 address translation.
        M OFFSET(0) NUMBITS(1) [
            Disable = 0,
            Enable = 1
        ]
    ]
}

pub struct SctlrEl2;

impl Readable for SctlrEl2 {
    type T = u64;
    type R = SCTLR_EL2::Register;

    #[inline]
    fn get(&self) -> Self::T {
        let value;
        unsafe {
            core::arch::asm!(
                "mrs {}, sctlr_el2",
                out(reg) value,
                options(nomem, nostack)
            );
        }
        value
    }
}

impl Writeable for SctlrEl2 {
    type T = u64;
    type R = SCTLR_EL2::Register;

    #[inline]
    fn set(&self, value: Self::T) {
        unsafe {
            core::arch::asm!(
                "msr sctlr_el2, {}",
                in(reg) value,
                options(nomem, nostack)
            );
        }
    }
}

pub const SCTLR_EL2: SctlrEl2 = SctlrEl2 {};
